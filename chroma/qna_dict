{"Why use such a simplistic model?": ["The model is indeed simplistic; however, it is adequate for describing and reasoning about many of the algorithms described in the first part of this course. We introduce other models later. We use the simplest model adequate for the problem at hand. We point out the model's weaknesses and we introduce other models as needed to deal with different problems."], "Can an agent refuse to receive a message?": ["In this model an agent cannot refuse to receive a message. If a channel is not empty then a message from the channel can be delivered to the agent independent of the state of the agent. Suppose you want to design an algorithm in which an agent X refuses to receive messages from an agent Z until it first receives a message from an agent Y. How would you use this model? In our model, agent X has to receive the message from Z in every state of X. Agent X can copy the message from Z into a local queue -- a local variable of X -- and process the message only after receiving the message from Y."], "Can a full channel block a sender from sending more messages?": ["In the model a sender is never blocked from sending a message. How could this model be used to analyze a system in which a channel has a maximum size, and when a channel is full it cannot accept messages? Our model assumes that channels have unlimited capacity. We can represent a situation in which channels have limited capacity in the following way. An agent has a local output queue into which the agent puts messages when the channel is full. Messages from this output queue are sent on the channel when the channel stops being full."], "Can you represent systems in which agents are created and deleted in the model?": ["The model doesn't have features that allow agents to be created and deleted. You may want to implement a system in which agents are created and deleted infinitely often. In this case the network of agents changes over time in an arbitrary fashion. The model doesn't represent such systems. A work around for the case in which agents are created or deleted a finite number of times is as follows. The network of agents in the model is made large enough to include agents that have not been created as yet and also include agents that have been deleted. An agent that has not been created is represented by an agent that is idle, i.e., one that doesn't receive messages. An agent this is deleted is represented in the same way."], "Can an agent process background jobs that are interrupted when messages arrive?": ["No, there are no interruptions in the model. After an agent is initiated it does nothing but execute receives or wait to execute receives. When an agent is executing a receive it is not interrupted by the arrival of another message."], "How do you represent channels that are not first in first out?": ["We use queues to represent states of first in first out channels, and we use other data structures -- such as multisets -- to represent states of other types of channels. Later we describe algorithms with different types of channels. For example, the state of a channel in which messages may overtake each other is a multiset or bag. A message is sent on a channel by adding the message to the multiset. A nonempty multiset may deliver any message in the mutliset to the receiving agent. Lossy channels, and channels in which messages have priorities, are also modeled by defining channel states appropriately."], "Can the model represent sequential composition of distributed computations?": ["Yes. There are problems in which we would like to start a distributed computation P; wait for P to finish, and then start another distributed computation Q. We want a barrier between P and Q. A barrier can be implemented in several ways. An agent, say a coordinator agent, sends messages to all agents to start P. The coordinator then detects termination of P; we discuss termination detection algorithms later. After detecting termination of P the coordinator sends messages to all agents to start Q."], "Can the model represent agents that make state transitions without receiving messages?": ["No, the model does not represent agents that make state transitions without receiving messages. The effect of a state transition without receiving a message can be simulated by an agent sending itself a message and carrying out the transition when it receives a message from itself. Some books on distributed systems allow agents to make internal state transitions -- these are transitions without receiving messages. Internal state transitions are represented by transitions in which an agent receives a message from itself. We represent an internal state change by having the agent send a message to itself; the agent makes a state change when it receives the message."], "Local clocks can be synchronized using NTP and other protocols. Why do you assume that clocks aren't synchronized?": ["Local clocks can, indeed, be synchronized very accurately; however, we do not assume that they are perfect. We use agents' local clocks for evaluating algorithm performance but not for proving correctness because even a small drift can cause race conditions. Consider an algorithm in which one agent carries out a computation starting at 1pm and another agent carries out a computation starting at 2pm. When we prove the correctness of our algorithms, we allow for the unlikely possibility that the agent starting its computation at 2pm does so before the agent that starts at 1pm. For evaluating performance, however, we assume that the agent that starts at 1pm usually does so before the agent that starts at 2pm."], "Dataflow doesn't have the concept of time. Does that mean that we cannot use time in our algorithms?": ["You can use the local clock of an agent in its receive function. Indeed, it can be helpful to do so. For example, you can have a sleep statement in a receive function. Properties of all dataflows of a system are properties of all timelines of the system. Dataflow doesn't make any assumptions about time, and so it works for all possible evaluations over time. You may be able to determine more properties of a system by making assumptions about local clocks; however, properties that you prove without making assumptions are properties that hold for any assumptions that you make."], "Does dataflow assume that events are instantaneous?": ["Dataflow makes no assumptions about the duration of an event. The only states of an agent that appear in dataflow are the states. You can, however, think of a vertex in a dataflow as an event in which a receive is executed in an infitisimally small time."], "Which agent starts a global snapshot algorithm?": ["Any one or more agents starts the algorithm. The initiators are not specified. The choice of initiators is usually evident from the application of the algorithm. For example, an agent that has been waiting a long time for a message may initiate a snapshot algorithm to determine if the agent is in a deadlocked cycle of agents."], "Can the snapshot algorithm be used to record the states and channels of a subset of agents, or does the algorithm have to span all agents and channels?": ["The snapshot algorithm can be used to record the states of a connected subset of agents. An agent doesn't propagate markers to agents outside the set of interest. The recorded states of the subset of agents and channels forms a part of a global snapshot. Some algorithms only used snapshots of subsets of agents."], "Is \"every message received in past is sent in past\" equivalent to \"every message sent in future is received in future\"?": ["Yes. Note that a message may be received in the final state."], "Can the algorithm be used to detect the states of a subset of agents and channels, or does the algorithm necessarily have to obtain a snapshot that encompasses all agents?": ["The algorithm can be modified to record states of subset S of agents and their incident channels. Modify the algorithm in the obvious way: An agent does not send markers to agents that are not in S. The subset of agent and channel states that are recorded are part of a global state. Some algorithms only need states of subsets of agents."], "Can the algorithm be used to take repeated snapshots?": ["Yes. Each initiation of the algorithm by an agent x at local time t is identified by the pair x, t. Every local snapshot and every marker is identified in this way. So, different executions of the global snapshot algorithm can be disambiguated in this way."]}